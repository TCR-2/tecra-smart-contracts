// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

import "./ownable.sol";
import "./reentry.sol";
import "./failsafe.sol";

contract Masternode is ownable, reentryGuard, failsafe {
    /// Coins need to run masternode
    uint256 public constant MN_AMOUNT = 10_000 * 1 ether;

    /// Current number of active masternodes to split daily reward
    uint256 public ActiveMasternodes;

    /// recalculation event every 1 day
    uint256 private constant DAY = 1 days;

    // Calculation event struct
    struct Calculation {
        uint256 timestamp;
        uint256 rewardPerNode;
    }
    /// Global list of calculation events
    Calculation[] public calculations;

    // reflection of Tecra halving process
    struct Stage {
        uint256 ending;
        uint256 dailyReward;
    }

    Stage[] public stages;
    uint256 public currentStage;

    struct Masternodes {
        uint256 masternodesOwned;
        uint256 lastClaim;
        uint256 claimableCoins;
    }

    /// Masternode storage data per user
    mapping(address => Masternodes) public userMasternodes;

    /// amount of coins send to contract by owner fund()
    uint256 public coinsFunded;
    /// amount of coins that can be claimed as MN rewards
    uint256 public coinsClaimable;

    event Funded(uint256 amount);
    event Claimed(address indexed user, uint256 amount);
    event MasternodeAdded(address indexed user);
    event MasternodeRemoved(address indexed user);

    /**
        Fund coins to be used as MN rewards
     */
    function fund() external payable onlyOwner {
        coinsFunded += msg.value;
        coinsClaimable += msg.value;
        emit Funded(msg.value);
    }

    /**
        Contract constructor
        @param stageList array of stages for contract operation
    */
    constructor(Stage[] memory stageList) {
        uint256 len = stageList.length;
        uint256 i;
        for (i; i < len; i++) {
            stages.push(stageList[i]);
        }
    }

    /**
        Receive directly send coins to create MN
        Will fail out-of-gas when send with default 2300 gas.
     */
    receive() external payable {
        _createMN(msg.sender);
    }

    /**
        Create new masternode.
        Need exactly 10k coins send in calling transaction.
    */
    function createMN() external payable {
        _createMN(msg.sender);
    }

    /**
        Create Masternode for someone
        @param user address to be MN owner
     */
    function createMasternodeFor(address user) external payable {
        _createMN(user);
    }

    /// internal create MN function
    function _createMN(address user) internal {
        require(msg.value == MN_AMOUNT, "Need exactly 10'000 coins");

        Masternodes storage m = userMasternodes[user];
        if (m.masternodesOwned > 0) {
            // claim coins
            uint256 toClaim = _claimable(m.masternodesOwned, m.lastClaim);
            // update only if need
            if (toClaim > 0) {
                m.claimableCoins += toClaim;
            }
        }
        m.lastClaim = calculations.length;
        m.masternodesOwned++;
        ActiveMasternodes++;
        emit MasternodeAdded(user);
    }

    /**
        Calculation event need to be call every day to record reward per masternode.
        Can be done by anyone.
        Loops if there was "skipped" event.
    */
    function calculate() external {
        require(calculations.length > 0, "Use calculateOnce");
        uint256 timeNow = block.timestamp;
        require(
            timeNow > calculations[calculations.length - 1].timestamp + DAY,
            "Too early"
        );
        while (
            timeNow > calculations[calculations.length - 1].timestamp + DAY
        ) {
            _calculate(timeNow);
        }
    }

    /**
        Do only one calculation event
     */
    function calculateOnce() external {
        _calculate(block.timestamp);
    }

    /**
        Calculate reward per pasternode for given timestamp.
     */
    function _calculate(uint256 timeNow) internal {
        uint256 len = calculations.length;
        uint256 required;
        if (len > 0) {
            Calculation memory last = calculations[len - 1];
            required = last.timestamp + DAY;
            require(timeNow > required, "Too early");
        } else {
            require(ActiveMasternodes > 0, "No MNs, can not initiate");
            required = timeNow;
        }
        _updateStage(required);
        uint256 toSplit = _dailyReward(required);
        Calculation memory current;
        current.rewardPerNode = ActiveMasternodes > 0
            ? toSplit / ActiveMasternodes
            : 0;
        current.timestamp = required;
        calculations.push(current);
    }

    /**
        Claim coins generated by masternode
    */
    function claim() external {
        _claim(msg.sender);
    }

    /**
        Claim masternode reward for someone - pay tx fee
        @param user address to claim
     */
    function claimFor(address user) external {
        _claim(user);
    }

    /**
        Internal claim function.
        Count reward for all owned MN and pay to user
     */
    function _claim(address user) internal {
        require(coinsClaimable > 0, "No coins to claim!");
        Masternodes storage m = userMasternodes[user];
        require(m.masternodesOwned > 0, "Not a masternode owner");

        uint256 coins = _claimable(m.masternodesOwned, m.lastClaim);
        coins += m.claimableCoins;
        coins = _updateClaimableReward(coins);
        require(coins > 0, "Nothing to claim");

        m.claimableCoins = 0;
        m.lastClaim = calculations.length;
        _transfer(user, coins);
        emit Claimed(user, coins);
    }

    /**
        Remove one masternode.
        Contract return all not-claimed coins and masternode collateral
     */
    function removeMN() external {
        _removeMasternode(msg.sender);
    }

    function _removeMasternode(address user) internal {
        Masternodes storage m = userMasternodes[user];
        require(m.masternodesOwned > 0, "Not MN owner");
        uint256 coins = _claimable(m.masternodesOwned, m.lastClaim);
        coins += m.claimableCoins;
        coins = _updateClaimableReward(coins);
        if (coins > 0) {
            emit Claimed(user, coins);
        }
        m.claimableCoins = 0;

        m.lastClaim = calculations.length;
        m.masternodesOwned--;

        ActiveMasternodes--;

        coins += MN_AMOUNT;
        _transfer(user, coins);
        emit MasternodeRemoved(user);
    }

    /**
        Check that contract can pay reward
     */
    function _updateClaimableReward(uint256 coins) internal returns (uint256) {
        if (coins > coinsClaimable) {
            coins = coinsClaimable;
            coinsClaimable = 0;
        } else {
            coinsClaimable -= coins;
        }
        return coins;
    }

    /**
        Calculate amount of coins that can be claimed
        @param masternodesOwned by user
        @param lastClaim done by user
        @return coins to be claimed
    */
    function _claimable(uint256 masternodesOwned, uint256 lastClaim)
        internal
        view
        returns (uint256 coins)
    {
        uint256 len = calculations.length;
        if (len == lastClaim || masternodesOwned == 0) return 0;
        for (lastClaim; lastClaim < len; lastClaim++) {
            coins += calculations[lastClaim].rewardPerNode * masternodesOwned;
        }
    }

    /**
        Daily reward for all masternodes.
        After last programmed stage it will be zero.
        @param timestamp date for which we check
        @return reward amount of coins for given timestamp
     */
    function _dailyReward(uint256 timestamp)
        internal
        view
        returns (uint256 reward)
    {
        uint256 len = stages.length;
        uint256 i = currentStage;
        for (i; i < len; i++) {
            Stage memory s = stages[i];
            if (timestamp < s.ending) {
                return s.dailyReward;
            }
        }
    }

    // update calculation stage to make less loops in dailyReward
    // this is called every calculation, daily reward every claim
    function _updateStage(uint256 timestamp) internal {
        uint256 len = stages.length;
        uint256 i = currentStage;
        for (i; i < len; i++) {
            Stage memory s = stages[i];
            if (timestamp < s.ending) {
                currentStage = i;
                break;
            }
        }
    }

    /**
        Internal guarded send coins function
        @param user address to send coins
        @param amount of coins to send
     */
    function _transfer(address user, uint256 amount) internal guarded {
        require(payable(user).send(amount), "Transfer failed");
    }

    //
    // readers
    //

    /**
        Check how many coins can be claimed from all masternodes for given user
        @param user address to check
        @return number of coins that can be claimed now
    */
    function getClaimable(address user) external view returns (uint256) {
        Masternodes memory m = userMasternodes[user];
        if (m.masternodesOwned == 0) return 0;
        return _claimable(m.masternodesOwned, m.lastClaim);
    }

    /**
        How much coins can be now claimed daily per masternode
        @return number of coins
    */
    function getDailyReward() external view returns (uint256) {
        if (ActiveMasternodes > 0) {
            return _dailyReward(block.timestamp) / ActiveMasternodes;
        }
        return 0;
    }

    /**
        Number of calculation events recorded
     */
    function getCalculations() external view returns (uint256) {
        return calculations.length;
    }

    /**
        Timestamp of last calculation event
     */
    function getLastCalculationTimestamp() external view returns (uint256) {
        return calculations[calculations.length - 1].timestamp;
    }

    //
    // backend
    //

    function removeMasternodeFor(address user) external onlyBackend {
        _removeMasternode(user);
    }

    address public backend;

    function updateBackend(address user) external onlyOwner {
        backend = user;
    }

    modifier onlyBackend() {
        require(msg.sender == backend, "Only for Backend");
        _;
    }
}
